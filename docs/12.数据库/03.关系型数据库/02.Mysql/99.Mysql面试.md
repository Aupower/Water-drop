---
icon: logos:mysql
title: Mysql 面试
date: 2020-09-12 10:43:53
order: 99
categories:
  - 数据库
  - 关系型数据库
  - Mysql
tags:
  - 数据库
  - 关系型数据库
  - Mysql
  - 面试
permalink: /pages/7b0caf/
---

# Mysql 面试

## 基础

### EXISTS 和 IN 有什么区别？

- `EXISTS` - 先对外表进行循环查询，再将查询结果放入 `EXISTS` 的子查询中进行条件比较，确定外层查询数据是否保留；
- `IN` - 先查询内表，将内表的查询结果作为条件，提供给外表查询语句进行比较；

索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。

比如下面这样：

```mysql
 SELECT * FROM A WHERE cc IN (SELECT cc FROM B)
 SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)
```

当 A 小于 B 时，用 `EXISTS`。因为 `EXISTS` 的实现，相当于外表循环，实现的逻辑类似于：

```sql
 for i in A
     for j in B
         if j.cc == i.cc then ...
```

当 B 小于 A 时用 `IN`，因为实现的逻辑类似于：

```sql
 for i in B
     for j in A
         if j.cc == i.cc then ...
```

哪个表小就用哪个表来驱动，A 表小就用 `EXISTS`，B 表小就用 `IN`；如果两个表大小相当，则使用 `EXISTS` 和 `IN` 的区别不大。

### UNION 和 UNION ALL 有什么区别？

`UNION` 和 `UNION ALL` 都是将两个结果集合并为一个，**两个要联合的 SQL 语句字段个数必须一样，而且字段类型要“相容”（一致）**。

- `UNION` 需要进行去重扫描，因此消息较低；而 `UNION ALL` 不会进行去重。
- `UNION` 会按照字段的顺序进行排序；而 `UNION ALL` 只是简单的将两个结果合并就返回。

### JOIN 有哪些类型？

连接用于连接多个表，使用 `JOIN` 关键字，并且条件语句使用 `ON` 而不是 `WHERE`。

`JOIN` 可以分为两大类：内连接和外连接。

![SQL JOIN](https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/sql-join.png)

#### 内连接（INNER JOIN）

内连接又称等值连接，**使用 `INNER JOIN` 关键字**。在没有条件语句的情况下**返回笛卡尔积**。

```sql
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
ON vendors.vend_id = products.vend_id;
```

自连接（`=`）

自连接可以看成内连接的一种，只是**连接的表是自身**而已。**自然连接是把同名列通过 `=` 连接起来**的，同名列可以有多个。

```sql
SELECT c1.cust_id, c1.cust_name, c1.cust_contact
FROM customers c1, customers c2
WHERE c1.cust_name = c2.cust_name
AND c2.cust_contact = 'Jim Jones';
```

自然连接（`NATURAL JOIN`）

内连接提供连接的列，而自然连接**自动连接所有同名列**。自然连接使用 `NATURAL JOIN` 关键字。

```sql
SELECT *
FROM Products
NATURAL JOIN Customers;
```

#### 外连接（`OUTER JOIN`）

外连接返回一个表中的所有行，并且仅返回来自此表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（Mysql 不支持）。

左连接（`LEFT JOIN`）

左外连接就是保留左表没有关联的行。

```sql
SELECT customers.cust_id, orders.order_num
FROM customers LEFT JOIN orders
ON customers.cust_id = orders.cust_id;
```

右连接（`RIGHT JOIN`）

右外连接就是保留右表没有关联的行。

```sql
SELECT customers.cust_id, orders.order_num
FROM customers RIGHT JOIN orders
ON customers.cust_id = orders.cust_id;
```

### 金钱相关的数据用什么类型存储？

MySQL 中有 3 种类型可以表示浮点数，分别是 `float`、`double` 和 `decimal`。

> float 和 double 为什么会丢失精度？

**采用 float 和 double 类型会丢失精度**。数据的精确度取决于分配给每种数据类型的存储长度。由于计算机只能存储二进制，所以浮点型数据在存储的时候，必须转化成二进制。

- 单精度类型 float 存储空间为 4 字节，即 32 位。
- 双精度类型 double 存储空间为 8 字节，即 64 位。

如果存储的数据转为二进制后，超过存储的位数，数据就被截断，因此存在丢失精度的可能。

【示例】丢失精度案例

```mysql
-- 创建表
CREATE TABLE `test` (
  `value` float(10,2) DEFAULT NULL
);

mysql> insert into test value (131072.32);
Query OK, 1 row affected (0.01 sec)

mysql> select * from test;
+-----------+
| value     |
+-----------+
| 131072.31 |
+-----------+
1 row in set (0.02 sec)
```

说明：示例中，使用 float 类型，明明保留了两位小数。但是写入的数据却从 `131072.32` 变成了 `131072.31` 。

> 选择什么类型可以不丢失精度？

`decimal` 类型是 MySQL 官方唯一指定能精确存储的类型。因此，对于不允许丢失精度的场景（如金钱相关的业务），请务必使用 `decimal` 类型。

> 扩展阅读：[MySQL 如何选择 float, double, decimal](http://blog.leanote.com/post/weibo-007/mysql_float_double_decimal)

### 如何存储 emoji 😃？

Mysql 中的默认字符集为 utf8，无法存储 emoji，如果要存储 emoji，必须使用 utf8mb4 字符集。

设置 utf8mb4 字符集方法如下：

```mysql
ALTER TABLE test
DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

### 什么是范式？什么是反范式？

> 什么是范式？

数据库规范化，又称**范式**，是数据库设计的指导理论。范式的目标是：使数据库结构更合理，消除存储异常，使数据冗余尽量小，增进数据的一致性。

> 什么是三大范式？

三大范式，从低到高，依次为：

- 1NF 要求属性具有原子性，不可再分解。
- 2NF 要求记录有唯一标识，即实体的唯一性，即**不存在部分依赖**。
- 3NF 是对字段的**冗余性**，要求任何字段不能由其他字段派生出来，它要求字段没有冗余，即**不存在传递依赖**。

现代数据库设计，一般最多满足 3NF——范式过高，虽然具有对数据关系更好的约束性，但也导致数据关系表增加而令数据库 IO 更繁忙。因此，在实际应用中，本来可以交由数据库处理的关系约束，很多都是在数据库使用程序中完成的。

> 什么是反范式？

范式和反范式：

- 范式 - 消除冗余
- 反范式 - 适当冗余数据，以提高查询效率——空间换时间

## 架构

### 一条 SQL 查询语句是如何执行的？

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202311030712357.png)

1. **连接器**：连接器负责跟客户端建立连接、获取权限、维持和管理连接。
2. **查询缓存**：命中缓存，则直接返回结果。弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。
3. **分析器**
   - **词法分析**：解析 SQL 关键字
   - **语法分析**：生成一颗对应的语法解析树
4. **优化器**
   - 根据语法树**生成多种执行计划**
   - **索引选择**：根据策略选择最优方式
5. **执行器**
   - 校验读写权限
   - 根据执行计划，调用存储引擎的 API 来执行查询
6. **存储引擎**：存储数据，提供读写接口

### 一条 SQL 更新语句是如何执行的？

更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：

- redo log（重做日志）
  - InnoDB 存储引擎独有的日志（物理日志）
  - 采用循环写入
- binlog（归档日志）
  - Mysql Server 层通用日志（逻辑日志）
  - 采用追加写入

为了保证 redo log 和 binlog 的数据一致性，所以采用两阶段提交方式更新日志。

### 一条 SQL 查询语句的执行顺序是怎样的？

一条完整的 SELECT 语句内部的执行顺序是这样的：

1. **FROM** - 对 FROM 子句中的左表 `<left_table>` 和右表 `<right_table>` 执行笛卡儿积（Cartesianproduct），产生虚拟表 VT1
2. **ON** - 对虚拟表 VT1 应用 ON 筛选，只有那些符合 `<join_condition>` 的行才被插入虚拟表 VT2 中
3. **JOIN** - 如果指定了 OUTER JOIN（如 LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表 VT2 中，产生虚拟表 VT3。如果 FROM 子句包含两个以上表，则对上一个连接生成的结果表 VT3 和下一个表重复执行步骤 1）～步骤 3），直到处理完所有的表为止
4. **WHERE** - 对虚拟表 VT3 应用 WHERE 过滤条件，只有符合 `<where_condition>` 的记录才被插入虚拟表 VT4 中
5. **GROUP BY** - 根据 GROUP BY 子句中的列，对 VT4 中的记录进行分组操作，产生 VT5
6. **CUBE|ROLLUP** - 对表 VT5 进行 CUBE 或 ROLLUP 操作，产生表 VT6
7. **HAVING** - 对虚拟表 VT6 应用 HAVING 过滤器，只有符合 `<having_condition>` 的记录才被插入虚拟表 VT7 中。
8. **SELECT** - 第二次执行 SELECT 操作，选择指定的列，插入到虚拟表 VT8 中
9. **DISTINCT** - 去除重复数据，产生虚拟表 VT9
10. **ORDER BY** - 将虚拟表 VT9 中的记录按照 `<order_by_list>` 进行排序操作，产生虚拟表 VT10。11）
11. **LIMIT** - 取出指定行的记录，产生虚拟表 VT11，并返回给查询用户

## 存储引擎

### Mysql 有哪些常见存储引擎？

- **InnoDB** - Mysql 的默认存储引擎。支持事务、外键、表级锁和行级锁、自动崩溃恢复。索引采用 B+ 树聚簇索引。
- **MyISAM** - Mysql 5.1 版本前的默认存储引擎。特性丰富，但不支持事务、外键、行级锁、自动崩溃恢复。索引采用 B+ 树非聚簇索引。
- **CSV** - 可以将 CSV 文件作为 Mysql 的表来处理，但这种表不支持索引。
- **Memory** - 适合快速访问数据，且数据不会被修改，重启丢失也没有关系。
- **NDB** - 用于 Mysql 集群场景。

### InnoDB 和 MyISAM 有哪些差异？

| 对比项 | MyISAM                                        | InnoDB                           |
| ------ | --------------------------------------------- | -------------------------------- |
| 主外键 | 不支持                                        | 支持                             |
| 事务   | 不支持                                        | 支持                             |
| 锁     | 支持表级锁                                    | 支持表级锁、行级锁               |
| 索引   | 采用非聚簇索引                                | 主键采用聚簇索引，以提高 IO 效率 |
| 表空间 | 小                                            | 大                               |
| 关注点 | 性能                                          | 事务                             |
| 计数器 | 维护了计数器，`SELECT COUNT(*)` 效率为 `O(1)` | 没有维护计数器，需要全表扫描     |

### 如何选择存储引擎？

- 大多数情况下，使用默认的 InnoDB 就够了。如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。
- 如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。
- 如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。

使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。

## 日志

### MySQL 有哪些类型的日志？

MySQL 日志文件有很多，包括 ：

- **错误日志**（error log）：错误日志文件对 MySQL 的启动、运行、关闭过程进行了记录，能帮助定位 MySQL 问题。
- **慢查询日志**（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。
- **一般查询日志**（general log）：一般查询日志记录了所有对 MySQL 数据库请求的信息，无论请求是否正确执行。
- **二进制日志**（bin log）：关于二进制日志，它记录了数据库所有执行的 DDL 和 DML 语句（除了数据查询语句 select、show 等），以事件形式记录并保存在二进制文件中。

还有两个 InnoDB 存储引擎特有的日志文件：

- **重做日志**（redo log）：重做日志至关重要，因为它们记录了对于 InnoDB 存储引擎的事务日志。
- **回滚日志**（undo log）：回滚日志同样也是 InnoDB 引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB 引擎不仅会记录 redo log，还会生成对应的 undo log 日志；如果事务执行失败或调用了 rollback，导致事务需要回滚，就可以利用 undo log 中的信息将数据回滚到修改之前的样子。

### binlog 和 redo log 有什么区别？

- bin log 会记录所有与数据库有关的日志记录，包括 InnoDB、MyISAM 等存储引擎的日志；而 redo log 只记 InnoDB 存储引擎的日志。
- 记录的内容不同，bin log 记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而 redo log 记录的是关于每个页（Page）的更改的物理情况。
- 写入的时间不同，bin log 仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有 redo ertry 被写入 redo log 中。
- 写入的方式也不相同，redo log 是循环写入和擦除，bin log 是追加写入，不会覆盖已经写的文件。

### 日志为什么要两阶段提交

## 索引

### 什么是索引？为什么要使用索引？

**“索引”是数据库为了提高查找效率的一种数据结构**。

日常生活中，我们可以通过检索目录，来快速定位书本中的内容。索引和数据表，就好比目录和书，想要高效查询数据表，索引至关重要。在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，设置合理的索引是数据库查询性能优化的最有效手段。

### 索引的优点和缺点是什么？

✔️️️️️️️ 索引的优点：

- **索引大大减少了服务器需要扫描的数据量**，从而加快检索速度。
- **索引可以帮助服务器避免排序和临时表**。
- **索引可以将随机 I/O 变为顺序 I/O**。
- 支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。**使用索引可以减少访问的行数，从而减少锁的竞争，提高并发**。
- 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。

❌ 索引的缺点：

- **创建和维护索引要耗费时间**，这会随着数据量的增加而增加。
- **索引需要占用额外的物理空间**，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。
- **写操作（`INSERT`/`UPDATE`/`DELETE`）时很可能需要更新索引，导致数据库的写操作性能降低**。

基于以上，可以归纳出索引的基本使用规则：

- 索引不是越多越好，不要为所有列都创建索引
- 要尽量避免冗余和重复索引
- 要考虑删除未使用的索引
- 尽量的扩展索引，不要新建索引
- 频繁作为 WHERE 过滤条件的列应该考虑添加索引

### 何时适用索引？何时不适用索引？

✔️️️️ 什么情况**适用**索引？

- **字段的数值有唯一性的限制**，如用户名。
- **频繁作为 `WHERE` 条件或 `JOIN` 条件的字段，尤其在数据表大的情况下**。
- **频繁用于 `GROUP BY` 或 `ORDER BY` 的字段**。将该字段作为索引，查询时就无需再排序了，因为 B+ 树本身就是按序存储的。
- **DISTINCT 字段需要创建索引**。

❌ 什么情况**不适用**索引？

- **频繁写操作**（ `INSERT`/`UPDATE`/`DELETE` ），也就意味着需要更新索引。
- **很少作为 `WHERE` 条件或 `JOIN` 条件的字段**，也就意味着索引会经常无法命中，没有意义，还增加空间开销。
- **非常小的表**，对于非常小的表，大部分情况下简单的全表扫描更高效。
- **特大型的表**，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。

### 索引有哪些常见数据结构？

在 Mysql 中，**索引是在存储引擎层而不是服务器层实现的**，所以，并没有统一的索引标准。不同存储引擎的索引的数据结构也不相同。下面是 Mysql 常用存储引擎对一些主要索引数据结构的支持：

| 索引数据结构/存储引擎 | InnoDB 引擎 | MyISAM 引擎 | Memory 引擎 |
| --------------------- | ----------- | ----------- | ----------- |
| **B+ 树索引**         | ✔️️️️️️️    | ✔️️️️️️️    | ✔️️️️️️️    |
| **Hash 索引**         | ❌          | ❌          | ✔️️️️️️️    |
| **Full Text 索引**    | ✔️️️️️️️    | ✔️️️️️️️    | ❌          |

Mysql 索引的常见数据结构：

- **哈希索引**
  - 因为索引数据结构紧凑，所以**查询速度非常快**。
  - **只支持等值比较查询** - 包括 `=`、`IN()`、`<=>`；**不支持任何范围查询**，如 `WHERE price > 100`。
  - **无法用于排序** - 因为哈希索引数据不是按照索引值顺序存储的。
  - **不支持部分索引匹配查找** - 因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。
  - **不能用索引中的值来避免读取行** - 因为哈希索引只包含哈希值和行指针，不存储字段，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。
  - 哈希索引有**可能出现哈希冲突**
    - 出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。
    - 如果哈希冲突多的话，维护索引的代价会很高。
- B 树索引
  - 适用于**全键值查找**、**键值范围查找**和**键前缀查找**，其中键前缀查找只适用于最左前缀查找。
  - 所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。
  - 所有的叶子节点由指针连接。

### 为什么 InnoDB 索引采用 B+ 树？

> B+ 树 vs B 树

- B+ 树只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据，所以 B+ 树的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。
- 另外，B+ 树叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。

> B+ 树 vs 二叉树

- 对于有 N 个叶子节点的 B+ 树，其搜索复杂度为 `O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。
- 在实际的应用当中， d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+ 树的高度依然维持在 1~3 层左右，也就是说一次数据查询操作只需要做 1~3 次的磁盘 I/O 操作就能查询到目标数据。
- 而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+ 树高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

一言以蔽之，使用 B+ 树，而不是二叉树，是为了减少树的高度，也就是为了减少磁盘 I/O 次数。

> B+ 树索引和 Hash 索引的差异

- **B+ 树索引支持范围查询**；Hash 索引不支持。
- **B+ 树索引支持联合索引的最左匹配原则**；Hash 索引不支持。
- **B+ 树索引支持排序**；Hash 索引不支持。
- **B+ 树索引支持模糊查询**；Hash 索引不支持。
- Hash 索引的等值查询比 B+ 树索引效率高。

综上，Hash 索引的应用场景很苛刻，不适用于绝大多数场景。

### 聚簇索引和非聚簇索引有什么区别？

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

主键索引又被称为**“聚簇索引（clustered index）”，其叶子节点存的是整行数据**。

- 聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快。
- 因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引**。
- InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行。

非主键索引又被称为**“二级索引（secondary index）”，其叶子节点存的是主键的值**。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。

- 如果语句是 `select * from T where ID=500`，即聚簇索引查询方式，则只需要搜索主键索引树；
- 如果语句是 `select * from T where k=5`，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为**回表**。

也就是说，**基于非聚簇索引的查询需要多扫描一棵索引树**。因此，我们在应用中应该尽量使用主键查询。

**显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。**

### 索引有哪些优化策略？

#### 索引基本原则

- **索引不是越多越好，不要为所有列都创建索引**。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。
- 要**尽量避免冗余和重复索引**。
- 要**考虑删除未使用的索引**。
- **尽量的扩展索引，不要新建索引**。
- **频繁作为 `WHERE` 过滤条件的列应该考虑添加索引**。

#### 覆盖索引

**覆盖索引是指：索引上的信息足够满足查询请求，不需要回表查询数据**。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**。

#### 最左匹配原则

**这里的最左前缀，可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符**。

如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否**存在（相等）**，遇到范围查询 (`>`、`<`、`BETWEEN`、`LIKE`) 就**不能进一步匹配**了，后续退化为线性查找。因此，**列的排列顺序决定了可命中索引的列数**。

**应该将选择性高的列或基数大的列优先排在多列索引最前列**。**“索引的选择性”是指不重复的索引值和记录总数的比值**，选择性越高，查询效率越高。但有时，也需要考虑 `WHERE` 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。

#### 前缀索引

**“前缀索引”是指索引开始的部分字符**。对于 `BLOB`/`TEXT`/`VARCHAR` 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。

前缀索引的优点是可以**大大节约索引空间**，从而**提高索引效率**。

前缀索引的缺点是**会降低索引的区分度**。此外，**`order by` 无法使用前缀索引，无法把前缀索引用作覆盖索引**。

#### 独立索引

- 索引列不能是表达式的一部分，也不能是函数的参数
- 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。

使用索引扫描来排序：ORDER BY 的字段作为索引，这样命中索引的查询结果，不需要额外排序

= 和 in 可以乱序：不需要考虑 =、IN 等的顺序，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。

### 哪些情况下，索引会失效？

导致索引失效的情况有：

- 对索引使用左或者左右模糊匹配
- 对索引使用函数或表达式
- 对索引隐式类型转换
- 联合索引不遵循最左匹配原则
- WHERE 子句中的 OR

### 普通索引和唯一索引，应该怎么选择？

普通索引和唯一索引的**查询性能相差微乎其微**。

## 事务

### 什么是事务，什么是 ACID？

**“事务”指的是满足 ACID 特性的一组操作**。事务内的 SQL 语句，要么全执行成功，要么全执行失败。可以通过 `Commit` 提交一个事务，也可以使用 `Rollback` 进行回滚。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202310092226555.png)

ACID 是数据库事务正确执行的四个基本要素。

- **原子性（Atomicity）**
  - 事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。
  - 回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
- **一致性（Consistency）**
  - 数据库在事务执行前后都保持一致性状态。
  - 在一致性状态下，所有事务对一个数据的读取结果都是相同的。
- **隔离性（Isolation）**
  - 一个事务所做的修改在最终提交以前，对其它事务是不可见的。
- **持久性（Durability）**
  - 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
  - 可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。

### 事务存在哪些并发一致性问题？

事务中存在的并发一致性问题有：

- 丢失修改
- 脏读
- 不可重复读
- 幻读

**“丢失修改”是指一个事务的更新操作被另外一个事务的更新操作替换**。

如下图所示，T<sub>1</sub> 和 T<sub>2</sub> 两个事务对同一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202310092226657.png)

**“脏读（dirty read）”是指当前事务可以读取其他事务未提交的数据**。

如下图所示，T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202310092226116.png)

**“不可重复读（non-repeatable read）”是指一个事务内多次读取同一数据，过程中，该数据被其他事务所修改，导致当前事务多次读取的数据可能不一致**。

如下图所示，T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202310092227863.png)

**“幻读（phantom read）”是指一个事务内多次读取同一范围的数据，过程中，其他事务在该数据范围新增了数据，导致当前事务未发现新增数据**。

事务 T<sub>1</sub> 读取某个范围内的记录时，事务 T<sub>2</sub> 在该范围内插入了新的记录，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202310092227171.png)

### 有哪些事务隔离级别，分别解决了什么问题？

为了解决以上提到的并发一致性问题，SQL 标准提出了四种“事务隔离级别”来应对这些问题。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。

事务隔离级别从低到高分别是：

- **“读未提交（read uncommitted）”** - 是指，**事务中的修改，即使没有提交，对其它事务也是可见的**。
- **“读已提交（read committed）” ** - 是指，**事务提交后，其他事务才能看到它的修改**。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
  - **读已提交解决了脏读的问题**。
  - 读已提交是大多数数据库的默认事务隔离级别，如 Oracle。
- **“可重复读（repeatable read）”** - 是指：**保证在同一个事务中多次读取同样数据的结果是一样的**。
  - **可重复读解决了不可重复读问题**。
  - **可重复读是 InnoDB 存储引擎的默认事务隔离级别**。
- **“串行化（serializable ）”** - 是指，**强制事务串行执行**，对于同一行记录，加读写锁，一旦出现锁冲突，必须等前面的事务释放锁。
  - **串行化解决了幻读问题**。由于强制事务串行执行，自然避免了所有的并发问题。
  - **串行化策略会在读取的每一行数据上都加锁**，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。

事务隔离级别对并发一致性问题的解决情况：

| 隔离级别 | 丢失修改 | 脏读 | 不可重复读 | 幻读 |
| :------: | :------: | :--: | :--------: | :--: |
| 读未提交 |   ✔️️️   |  ❌  |     ❌     |  ❌  |
| 读已提交 |   ✔️️️   | ✔️️️ |     ❌     |  ❌  |
| 可重复读 |   ✔️️️   | ✔️️️ |    ✔️️️    |  ❌  |
| 可串行化 |   ✔️️️   | ✔️️️ |    ✔️️️    | ✔️️️ |

### 各事务隔离级别是如何实现的？

Mysql 中的事务功能是在存储引擎层实现的，**并非所有存储引擎都支持事务功能**。InnoDB 是 Mysql 的首先事务存储引擎。

四种隔离级别具体是如何实现的呢？

以 InnoDB 的事务实现来说明：

- 对于“读未提交”隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；
- 对于“串行化”隔离级别的事务来说，通过加读写锁的方式来避免并行访问；
- 对于“读提交”和“可重复读”隔离级别的事务来说，它们都是通过 ReadView 来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。
  - “读提交”隔离级别是在“每个语句执行前”都会重新生成一个 ReadView
  - “可重复读”隔离级别是在“启动事务时”生成一个 ReadView，然后整个事务期间都在用这个 ReadView。

### 什么是 MVCC？

**MVCC 是 Multi Version Concurrency Control 的缩写，即“多版本并发控制”**。MVCC 的设计目标是提高数据库的并发性，采用非阻塞的方式去处理读/写并发冲突，可以将其看成一种乐观锁。

不仅是 Mysql，包括 Oracle、PostgreSQL 等其他关系型数据库都实现了各自的 MVCC，实现机制没有统一标准。**MVCC 是 InnoDB 存储引擎实现事务隔离级别的一种具体方式**。其主要用于实现读已提交和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### MVCC 的实现原理是什么？

MVCC 的实现原理，主要基于隐式字段、UndoLog、ReadView 来实现。

#### 隐式字段

InnoDB 存储引擎中，数据表的每行记录，除了用户显示定义的字段以外，还有几个数据库隐式定义的字段：

- `row_id` - **隐藏的自增 ID**。如果数据表没有指定主键，InnoDB 会自动基于 `row_id` 产生一个聚簇索引。
- `trx_id` - **最近修改的事务 ID**。事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；
- `roll_pointer` - **回滚指针**，指向这条记录的上一个版本。

#### UndoLog

MVCC 的多版本指的是多个版本的快照，快照存储在 UndoLog 中。该日志通过回滚指针 `roll_pointer` 把一个数据行的所有快照链接起来，构成一个**版本链**。

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202310092231914.png)

#### ReadView

**ReadView 就是事务进行快照读时产生的读视图（快照）**。

ReadView 有四个重要的字段：

- `m_ids` - 指的是在创建 ReadView 时，当前数据库中“活跃事务”的事务 ID 列表。注意：这是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- `min_trx_id` - 指的是在创建 ReadView 时，当前数据库中“活跃事务”中事务 id 最小的事务，也就是 `m_ids` 的最小值。
- `max_trx_id` - 这个并不是 m_ids 的最大值，而是指创建 ReadView 时当前数据库中应该给下一个事务分配的 ID 值，也就是全局事务中最大的事务 ID 值 + 1；
- `creator_trx_id` - 指的是创建该 ReadView 的事务的事务 ID。

在创建 ReadView 后，我们可以将记录中的 trx_id 划分为三种情况：

- 已提交事务
- 已启动但未提交的事务
- 未启动的事务

![](https://raw.githubusercontent.com/dunwu/images/master/snap/202310092230178.png)

> ReadView 如何判断版本链中哪个版本可见？

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- `trx_id == creator_trx_id` - 表示 `trx_id` 版本记录由 ReadView 所代表的当前事务产生，当然可以访问。
- `trx_id < min_trx_id` - 表示 `trx_id` 版本记录是在创建 ReadView 之前已提交的事务生成的，当前事务可以访问。
- `trx_id >= max_trx_id` - 表示 `trx_id` 版本记录是在创建 ReadView 之后才启动的事务生成的，当前事务不可以访问。
- `min_trx_id <= trx_id < max_trx_id` - 需要判断 `trx_id` 是否在 `m_ids` 列表中
  - 如果 `trx_id` 在 `m_ids` 列表中，表示生成 `trx_id` 版本记录的事务依然活跃（未提交事务），当前事务不可以访问。
  - 如果 `trx_id` 不在 `m_ids` 列表中，表示生成 `trx_id` 版本记录的事务已提交，当前事务可以访问。

这种通过“版本链”来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。

### MVCC 实现了哪些隔离级别，如何实现的？

对于“读已提交”和“可重复读”隔离级别的事务来说，它们都是通过 MVCC 的 ReadView 机制来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。

- **可重复读隔离级别只有在启动事务时才会创建 ReadView，然后整个事务期间都使用这个 ReadView**。这样就保证了在事务期间读到的数据都是事务启动前的记录。
- **读已提交隔离级别每次读取数据时都会创建一个 ReadView**。这意味着，事务期间的多次读取同一条数据，前后读取的数据可能会出现不一致——因为，这期间可能有另外一个事务修改了该记录，并提交了事务。

这两个隔离级别的实现是通过“事务的 ReadView 里的字段”和“记录中的两个隐藏列”的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。

MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：

- 针对**快照读**（普通 `SELECT` 语句），**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（`SELECT ... FOR UPDATE` 等语句），**通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 `SELECT ... FOR UPDATE` 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。

## 锁

### Mysql 中有哪些锁？

为了解决并发一致性问题，Mysql 支持了很多种锁来实现不同程度的隔离性，以保证数据的安全性。

#### 独享锁和共享锁

InnoDB 实现标准行级锁定，根据是否独享资源，可以把锁分为两类：

- **独享锁（Exclusive）**，简写为 X 锁，又称为“**写锁**”、“**排它锁**”。
  - 独享锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。
  - 使用方式：`SELECT ... FOR UPDATE;`
- **共享锁（Shared）**，简写为 S 锁，又称为“**读锁**”。
  - 共享锁锁定的资源可以被其他用户读取，但不能修改。在进行 `SELECT` 的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。
  - 使用方式：`SELECT ... LOCK IN SHARE MODE;`

> 为什么要引入读写锁机制？

实际上，读写锁是一种通用的锁机制，并非 Mysql 的专利。在很多软件领域，都存在读写锁机制。

因为读操作本身是线程安全的，而一般业务往往又是读多写少的情况。因此，如果对读操作进行互斥，是不必要的，并且会大大降低并发访问效率。正式为了应对这种问题，产生了读写锁机制。

读写锁的特点是：**读读不互斥**、**读写互斥**、**写写互斥**。简言之：**只要存在写锁，其他事务就不能做任何操作**。

> 注：InnoDB 下的行锁、间隙锁、next-key 锁统统属于独享锁。

#### 悲观锁和乐观锁

基于加锁方式分类，Mysql 可以分为悲观锁和乐观锁。

- **悲观锁** - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
  - 在查询完数据的时候就把事务锁起来，直到提交事务（`COMMIT`）
  - 实现方式：**使用数据库中的锁机制**。
- **乐观锁** - 假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。只在更新的时候，判断一下在此期间是否有其他线程更新该数据。
  - 实现方式：**更新数据时，先使用版本号机制或 CAS 算法检查数据是否被修改**。

为什么要引入乐观锁？

乐观锁也是一种通用的锁机制，在很多软件领域，都存在乐观锁机制。

**锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能**。那么，为了提高并发度，能不能尽量不加锁呢？

乐观锁，顾名思义，就是假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。虽然不加锁，但不意味着什么都不做，而是在更新的时候，判断一下在此期间是否有其他线程更新该数据。乐观锁最常见的实现方式，是使用版本号机制或 CAS 算法（Compare And Swap）去实现。

乐观锁的**优点**是：减少锁竞争，提高并发度。

乐观锁的**缺点**是：

- **存在 ABA 问题**。所谓的 ABA 问题是指在并发编程中，如果一个变量初次读取的时候是 A 值，它的值被改成了 B，然后又其他线程把 B 值改成了 A，而另一个早期线程在对比值时会误以为此值没有发生改变，但其实已经发生变化了
- 如果乐观锁所检查的数据存在大量锁竞争，会由于**不断循环重试，产生大量的 CPU 开销**。

#### 全局锁、表级锁、行级锁

前文提到了，**锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能**。在不得不加锁的情况下，显然，加锁的范围越小，锁竞争的发生频率就越小，系统的并发程度就越高。但是，加锁也需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销，**锁粒度越小，系统的锁操作开销就越大**。因此，在选择锁粒度时，也需要在锁开销和并发程度之间做一个权衡。

根据加锁的范围，MySQL 的锁大致可以分为：

- **全局锁** - **“全局锁”会锁定整个数据库**。
- **表级锁（table lock）** - **“表级锁”锁定整张表**。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。表级锁有：
  - **表锁** - 表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。
  - **元数据锁（MDL）** - MDL 不需要显式使用，在访问一个表的时候会被自动加上。
    - 增删改查，加读锁
    - 结构变更，加写锁
  - **意向锁（Intention Lock）**
  - **自增锁（AUTO-INC）**
- **行级锁（row lock）** - **“行级锁”锁定指定的行记录**。这样其它线程还是可以对同一个表中的其它行记录进行操作。行级锁有：
  - **记录锁（Record Lock）**
  - **间隙锁（Gap Lock）**
  - **临键锁（Next-Key Lock）**
  - **插入意向锁**

以上各种加锁粒度，在不同存储引擎中的支持情况并不相同。如：InnoDB 支持全局锁、表级锁、行级锁；而 MyISAM 只支持全局锁、表级锁。

每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。

### 死锁是如何产生的？

**“死锁”是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象**。

产生死锁的场景：

- 当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。
- 多个事务同时锁定同一个资源时，也会产生死锁。

### 如何避免死锁？

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。由此可知，要想避免死锁，就要从这几个必要条件上去着手：

- 更新表时，**尽量使用主键更新**，减少冲突；
- **避免长事务**，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；
- **设置合理的锁等待超时参数**，我们可以通过 `innodb_lock_wait_timeout` 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。
- 在编程中**尽量按照固定的顺序来处理数据库记录**，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；
- 在允许幻读和不可重复读的情况下，尽量使用读已提交事务隔离级别，可以避免 Gap Lock 导致的死锁问题；
- 还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。

### 如何解决死锁？

当出现死锁以后，有两种策略：

- **设置事务等待锁的超时时间**。这个超时时间可以通过参数 `innodb_lock_wait_timeout` 来设置。
- **开启死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 `on`，表示开启这个逻辑。

在 InnoDB 中，`innodb_lock_wait_timeout` 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我直接把这个时间设置成一个很小的值，比如 1s，也是不可取的。当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。

所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 `innodb_deadlock_detect` 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：**将持有最少行级排它锁的事务进行回滚**。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。因此，死锁检测可能会耗费大量的 CPU。

## 优化

### 如何发现慢 SQL？

慢 SQL 的监控主要通过两个途径：

- **慢查询日志**：开启 MySQL 的慢查询日志，再通过一些工具比如 mysqldumpslow 去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。
- **服务监控**：可以在业务的基建中加入对慢 SQL 的监控，常见的方案有字节码插桩、连接池扩展、ORM 框架过程，对服务运行中的慢 SQL 进行监控和告警。

### 什么是执行计划？

### 如何分析执行计划？

### 哪种 COUNT 性能最好？

> 先说结论：按照效率排序的话，`COUNT(字段)` < `COUNT(主键 id)` < `COUNT(1)` ≈ `COUNT(*)`。**推荐采用 `COUNT(*)`** 。

- **对于 `COUNT(主键 id)` 来说**，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

- **对于 `COUNT(1)` 来说**，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

- 单看这两个用法的差别的话，你能对比出来，`COUNT(1)` 执行得要比 `COUNT(主键 id)` 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。

- **对于 `COUNT(字段)` 来说**：
  - 如果这个“字段”是定义为 `not null` 的话，一行行地从记录里面读出这个字段，判断不能为 `null`，按行累加；
  - 如果这个“字段”定义允许为 `null`，那么执行的时候，判断到有可能是 `null`，还要把值取出来再判断一下，不是 `null` 才累加。
  - 也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。

**但是 `COUNT(*)` 是例外**，并不会把全部字段取出来，而是专门做了优化，不取值。`COUNT(*)` 肯定不是 `null`，按行累加。

不同的 MySQL 引擎中，`COUNT(*)` 有不同的实现方式：

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 `COUNT(*)` 的时候会直接返回这个数，效率很高；
- 而 InnoDB 引擎就麻烦了，它执行 `COUNT(*)` 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

> 为什么 InnoDB 不跟 MyISAM 一样，也维护一个计数器？

因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。

InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 `COUNT(*)` 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。

- MyISAM 表虽然 `COUNT(*)` 很快，但是不支持事务；
- `show table status` 命令虽然返回很快，但是不准确；
- InnoDB 表直接 `COUNT(*)` 会遍历全表，虽然结果准确，但会导致性能问题。

> 如何优化查询计数？

可以使用 Redis 保存计数，但存在丢失更新一集数据不一致问题。

可以使用数据库其他表保存计数，但要用事务进行控制，增/删数据时，同步改变计数。

## 参考资料

- [《高性能 MySQL》](https://book.douban.com/subject/23008813/)
- [MySQL 实战 45 讲](https://time.geekbang.org/column/intro/139)
- [图解 MySQL 介绍](https://xiaolincoding.com/mysql/)
